[{"content":"Description Implemented and managed GitLab CI/CD pipelines to automate the build, test, and deployment processes for multiple projects. Utilized Terraform to provision and manage AWS infrastructure, ensuring scalability, reliability, and cost-effectiveness. Integrated Terraform scripts into GitLab CI/CD pipelines, automating the deployment and configuration of infrastructure as part of the continuous integration process. Collaborated with team to define CI/CD best practices, including the use of Terraform for infrastructure as code (IaC) to enhance reproducibility, consistency and ensure seamless integration into the software development lifecycle. Configured and maintained GitLab Runners for efficient parallelized builds, optimizing pipeline performance. Worked closely with other developers to troubleshoot build failures, resolve integration issues, and enhance overall pipeline reliability. Integrated security scanning tools into CI/CD pipelines to ensure code quality and identify vulnerabilities early in the development process. Created and maintained documentation for CI/CD processes and Terraform configurations, enabling knowledge transfer and onboarding of new team members. Developed a Python-based AWS Lambda function and deployed it using Terraform and GitLab pipelines, contributing to the automation and efficiency of the deployment process. ","permalink":"https://arunaideepan.github.io/portfolio/experience/lightcast/","summary":"Description Implemented and managed GitLab CI/CD pipelines to automate the build, test, and deployment processes for multiple projects. Utilized Terraform to provision and manage AWS infrastructure, ensuring scalability, reliability, and cost-effectiveness. Integrated Terraform scripts into GitLab CI/CD pipelines, automating the deployment and configuration of infrastructure as part of the continuous integration process. Collaborated with team to define CI/CD best practices, including the use of Terraform for infrastructure as code (IaC) to enhance reproducibility, consistency and ensure seamless integration into the software development lifecycle.","title":"Software Engineer"},{"content":"Description Set up an OpenStack Ussuri minimal environment consisting of two nodes (controller and compute node) for team members\u0026rsquo; training purposes. Configured and deployed OpenStack services on the controller and compute nodes. Implemented network configurations and security settings to ensure the stability and security of the OpenStack environment. Collaborated with colleagues to troubleshoot issues and optimize the performance of the OpenStack setup. ","permalink":"https://arunaideepan.github.io/portfolio/experience/checktronix/","summary":"Description Set up an OpenStack Ussuri minimal environment consisting of two nodes (controller and compute node) for team members\u0026rsquo; training purposes. Configured and deployed OpenStack services on the controller and compute nodes. Implemented network configurations and security settings to ensure the stability and security of the OpenStack environment. Collaborated with colleagues to troubleshoot issues and optimize the performance of the OpenStack setup. ","title":"Software Engineer Intern"},{"content":"LD_PRELOAD: Unleashing Your Inner Linux Wizardüêß Imagine having a superpower that lets you secretly modify how any program runs, without touching its source code. Welcome to the wild world of LD_PRELOAD, the coolest trick in the Linux hacker\u0026rsquo;s toolkit!\nWhat the Heck is LD_PRELOAD? Think of LD_PRELOAD as a sneaky library loader that whispers to your system, \u0026ldquo;Hey, I want to intercept and modify library calls before the program even knows what\u0026rsquo;s happening.\u0026rdquo; It\u0026rsquo;s like being a digital ninja, silently modifying program behavior.\nHow Does This Magic Work? When you set LD_PRELOAD, you\u0026rsquo;re telling the dynamic linker: \u0026ldquo;Load my library first, before any other libraries.\u0026rdquo; This means:\nYour custom library gets priority You can override system functions You can add superpowers to existing programs Technical Deep Dive: Dynamic Linking Explained Before diving into the code, let\u0026rsquo;s understand how dynamic linking works:\nDynamic Linker (ld.so): Responsible for loading shared libraries at runtime Symbol Resolution: Finds and links function calls to their correct implementations Library Search Path: /etc/ld.so.conf LD_LIBRARY_PATH environment variable Default system paths Simple example Let\u0026rsquo;s dive deep into a practical example of LD_PRELOAD that demonstrates its true power. We\u0026rsquo;ll create a program that secretly injects a joke into every printf call without modifying the original source code!\nThe Code Breakdown // interceptor.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; // define a function pointer type for printf typedef int (*printf_func)(const char *format, ...); int printf(const char *format, ...) { // dynamic loading of the real printf static printf_func real_printf = NULL; if (!real_printf) { void *handle = dlopen(\u0026#34;libc.so.6\u0026#34;, RTLD_LAZY); real_printf = dlsym(handle, \u0026#34;printf\u0026#34;); } // prepare variadic arguments va_list args; va_start(args, format); // call the original printf int result = real_printf(format, args); // inject our programmer joke real_printf(\u0026#34;\\nWhich body part does a programmer know best?\\nA: ARM\\n\u0026#34;); va_end(args); return result; } Let\u0026rsquo;s Break Down the program Dynamic Function Interception\nWe create a custom printf function that looks exactly like the system\u0026rsquo;s printf dlopen() and dlsym() are used to find the original printf function This allows us to call the original function while adding our own twist Variadic Argument Handling\nva_list, va_start(), and va_end() let us handle functions with variable arguments This is crucial for intercepting printf, which can take any number of arguments Compilation Incantation\ngcc -shared -fPIC interceptor.c -o funprintf.so -ldl -shared: Create a shared library -fPIC: Position Independent Code (required for shared libraries) -ldl: Link against the dynamic loading library Practical Spell Casting üßô‚Äç‚ôÇÔ∏è To use our magic:\n// test-printf.c #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;hello\u0026#34;); return 0; } gcc -shared -fPIC interceptor.c -o funprintf.so -ldl # complie test program gcc test-printf.c -o test export LD_PRELOAD=./funprintf.so # run with our printf interceptor ./test hello Which body part does a programmer know best? A: ARM Under the Hood: What\u0026rsquo;s Really Happening? The dynamic linker loads our library first Our printf function gets called instead of the system\u0026rsquo;s We execute the original printf Then we sneak in our joke Practical Use Cases Debugging:\nInject logging without source code modification Override error handling Create custom error reporting mechanisms Security and Monitoring:\nTrack function calls Intercept system calls to log activities Create custom access controls Implement lightweight sandboxing Humor Injection: As demonstrated (most important, obviously!)\nPerformance Profiling:\nMeasure function execution times Track resource usage Create custom profiling tools Legacy System Modifications: Add features without recompiling\nSafety and Caution Intercepting system calls can lead to unexpected behavior, May break application functionality. Security implications if not carefully implemented Use for learning, debugging and fun, not in production systems Limitations and Considerations Not all functions can be easily intercepted Works best with C and dynamically linked libraries Performance overhead Requires deep understanding of system internals The Hacker\u0026rsquo;s Wisdom LD_PRELOAD isn\u0026rsquo;t just a technique; it\u0026rsquo;s a mindset. It\u0026rsquo;s about understanding systems so deeply that you can reshape them from the inside.\nPro Tip: With great power comes great responsibility. Start small, experiment safely, and always have a backup!\n","permalink":"https://arunaideepan.github.io/portfolio/experience/blog/blog-1/","summary":"LD_PRELOAD: Unleashing Your Inner Linux Wizardüêß Imagine having a superpower that lets you secretly modify how any program runs, without touching its source code. Welcome to the wild world of LD_PRELOAD, the coolest trick in the Linux hacker\u0026rsquo;s toolkit!\nWhat the Heck is LD_PRELOAD? Think of LD_PRELOAD as a sneaky library loader that whispers to your system, \u0026ldquo;Hey, I want to intercept and modify library calls before the program even knows what\u0026rsquo;s happening.","title":"LD_PRELOAD - The Linux Hack That Feels Like Black Magic"}]